## 생성자(Constructor)

생성자(Constructor)
생정자란 클래스의 인스턴스가 생성될 떄 호출되는 **인스턴스 초기화 메서드**로 해당 클래스와 이름이 똑같은 메소드이다. 생성자 역시 메서드이므로 클래스 내부에서 선언되며, 주의할 점은 **모든 생성자는 리턴값을 가지지 않는다는 것이다.**

기본적으로 모든 생성자는 리턴타입이 없기 때문에 `void` 역시 생략된다.

```java
class Sample {
    int a;
    int b;
    Sample() { // Sample 클래스의 생성자
        a = 10;
        b = 20; // Sample 클래스의 인스턴스 변수들의 초기값을 설정해줌
    }
}
```

위와 같은 경우, Sample의 모든 인스턴스의 변수 a,b의 초기값은 각각 10, 20이 된다.

<br>

---

### 기본 생성자(Default Constructor)

```java
class Sample {
    Sample {}
}
```

생성자를 별도로 만들지 않아도 자바는 자동으로 컴파일러를 통해 **기본 생성자**를 만들어준다. 기본생성자는 위와 같은 형식을 가지며 실제로는 클래스에서 보이지 않는다. 이때, 기본 생성자는 참조형 필드는 null로 기본형 필드는 0으로 초기화해준다. 기본 생성자는 파라미터가 존재하지 않는다.

단, 기본 생성자는 클래스 내에 정의된 생성자가 하나도 없을 때만 사용 가능하다.

<br>

---

### 생성자 추가

생성자는 반드시 기본생성자만을 사용할 필요가 없으며, 상황에 따라서는 재정의가 가능하다. 또한 **오버로딩**을 통해 여러 개를 생성할 수 있다. 단 주의할 점은 **사용자가 직접 생성자를 만들 경우, 기본생성자는 더 이상 사용할 수 없다.** 따라서 기본 생성자를 사용하고 싶으면 사용자가 직접 작성해서 명시해줘야 한다.

```java
class Sample {
    Sample() { // 직접 작성하지 않을 경우, 파라미터가 있는 생성자가 존재하는 클래스는 기본생성자를 사용할 수 없다
    }

    Sample(int x, int y) {
    }
}
```

<br>

#### 파라미터가 있는 생성자

```java
class Sample {
    int width;
    int heightl

    Sample(int x int y) {
        width = x;
        width - y;
    }
}

```

생성자도 메서드처럼 **파라미터**를 선언하여 호출 시 값을 넘겨받아 인스턴스 초기화 작업에 쓸 수 있다. 이는 각각의 인스턴스마다 인스턴스변수값을 달리해야하는 클래스에 유용하다. 생성자에 파라미터를 두면 인스턴스 생성 이후 인스턴스변수들을 별도로 초기화할 필요가 없어서 편리함.

<br>

##### 기존 인스턴스변수 초기화 방식

```java
Sample s = new Sample();
s.width = 10;
s.height = 20;
```

##### 파라미터가 있는 생성자를 통한 인스턴스 초기화

```java
Sample s = new Sample(10, 20);
```

파라미터가 있는 생성자 사용 시 코드가 더욱 간결하고 직관적임.

<br>

---

### 생성자 호출

생성자는 인스턴스 생성 시 반드시 호출될 수 밖에 없음. 이전까지 클래스의 인스턴스를 생성 시 다음과 같은 코드를 작성했는데,

```java
Sample s = new Sample(인수 목록);
```

이때 사용되는 `Sample()`이 생성자를 사용한 것이다.

객체는 연산자 `new`에 의해서 생성되며 이때 생성자가 호출되어 인스턴스변수들을 초기화한다. 그리고 연산자 `new`의 결과로 인스턴스의 주소가 반환되어 참조변수 s에 저장되는 것이다.

인스턴스를 생성할 때는 반드시 클래스 내에 정의된 생성자 중 하나를 선택하여(생성자가 없을 경우 기본생성자 사용) 지정해줘야 함.

<br>

---

### this()와 this

#### this()

생성자에서 **같은 클래스 내 다른 생성자를 호출**할 떄 `this()`를 사용한다.
`this()` 메소드에 인수를 전달하면, 생성자 중에서 **메소드 시그니처**가 일치하는 다른 생성자를 찾아 호출해줌.

> 메소드 시그니처란 메소드의 이름 + 메소드 내 파라미터 배열을 의미함.

##### this() 사용 예시

```java
class Sample {
    int x;
    int y;

    Sample() {
        this(10, 20); // 생성자 내에서 생성자 호출
    }

    Sample(int x, int y) {
        this.x = x;
        this.y = y;
    }
}
```

위의 예시에서 생성자 `Sample()`에서 또다른 생성자 `Sample(int x, int y))`를 호출할 때 `this()`를 사용. 또한 생성자의 첫번째 줄에서 호출함. 이처럼 생성자 내에서 또 다른 생성자를 호출할 때는 다음과 같은 규칙을 가짐

1. 생성자의 이름으로 클래스이름 대신 this 사용
2. `this()`는 첫번째 줄에서만 호출 가능

첫줄에서 호출하지 않으면, 초기화 작업이 중복적으로 발생하는 불필요한 경우가 발생하므로 반드시 2번 규칙을 따른다.

<br>

##### this()의 장점

생성자 내에서 생성자를 호출하는 것은 코드를 유기적으로 연결해주고, 간략하게 만들어준다.

앞서 작성한 예시에서도 `this()`를 사용하지 않으면 다음과 같이 코드가 길어진다.

```java
Sample() {
    int x = 10;
    int y = 20;
}
```

따라서 `this()`를 사용하면 코드가 간결해지고 수정 시 그 양이 줄어들어 유지보수가 편리해짐.

<br>

#### this

`this`는 `this()`와 전혀 다른 것으로, **참조변수로써 호출한 인스턴스 자신**을 의미한다. 이러한 `this` 참조 변수는 해당 인스턴스의 주소를 가르킴.

```java
class Sample {
    Sample(int x, int y) {
        this.x = x;
        this.y = y;
    }
}
```

앞서 작성한 예시에서도 `this` 참조변수가 사용되는데 `this`를 사용하므로써 _인스턴스 변수 `x`가 해당 생성자의 지역변수 `x`와 이름이 동일해도 명확하게 구분이 가능해진다._

인스턴스 자신을 가르키는 것이므로 인스턴스 생성이 필요없는 **클래스 메서드**에서는 사용이 불가능하다. 또한 _기본생성자처럼_ `this`역시 모든 인스턴스메서드의 지역변수로 숨겨진 채로 존재한다.

<br>

#### 복사용 생성자

생성자를 통해 현재 인스턴스의 상태를 복사할 수 있다.

```java
Sample(Sample s) {
    this.(s.x, s.y); // Sample(int x, int y)
}
```

파라미터를 특정 인스턴스로 둘 경우, 해당 인스턴스변수들이 생성자를 통해 복사된다. 이는 서로 독립적인 메모리공간을 확보하므로 생성 이후 값들이 변경되어도 서로 영향을 주지 않는다.
