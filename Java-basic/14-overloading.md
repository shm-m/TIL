## 오버로딩(Overloading)

메서드의 파리미터는 데이터타입과 갯수가 메서드 생성 시 지정되기 때문에 다른 데이터타입의 혹은 정해진 개수와 다른 인자가 들어올 수 없음.

따라서 동일한 기능이 요구되지만, <u>다른 데이터타입 혹은 갯수의 파라미터를 받으면 다른 메소드로 만들어야 함.</u>

이 때 새로 생성하는 메서드는 기존의 메서드와 동일한 이름으로 생성이 가능하다. 물론 메서드는 변수와 마찬가지로 한 클래스 내에서 동일한 이름의 메서드를 만들 수 없지만, **오버로딩**으로써 같은 이름의 메서드를 여러 개 생성하는게 가능해지며, 이를 **오버로딩**이라고 한다.

<br>
<br>

### 메서드 오버로딩(Method Overloading)

따라서 오버로딩(혹은 메서드 오버로딩)이란 <u>파라미터의 개수나 데이터타입(시그니처)</u>을 다르게 하여 같은 이름의 메소드를 중복하여 정의하는 것을 의미한다.

```java
class Sample {
    int add(int x, int y) {
        return x + y;
    }

    // 하단의 메서드는 상단의 메서드와 동일한 이름이지만, 오버로딩을 통해 파라미터를 달리 하여 사용 가능
    long add(long x, long y) {
        return x + y;
    }
}
```

<br>
<br>

---

### 오버로딩의 조건

그러나 무작정 동일한 이름의 메서드를 사용하면 에러가 발생한다. 따라서 에러를 발생시키지 않고 오버로딩으로 인식시키기 위해서는 다음과 같은 조건을 지켜야 한다.

1. **동일한 메서드의 이름**
2. **파라미터의 타입 혹은 갯수가 달라야 함.**

위의 조건을 하나라도 지키지 않을 경우, 자바는 컴파일 에러를 발생시킨다. 단, 파라미터가 복수 개고, 그 데이터타입이 다를 경우, *순서를 달리해서 재생성*하는 것은 오버로딩으로 취급한다.

또한 **리턴타입은 오버로딩에 영향을 주지 않는다.**

<br>

#### 파라미터의 개수와 데이터타입이 같으나 순서만 달리하여 오버로딩으로 간주하는 경우

```java
class Sample {
    long add(int x, long y) {
        return x + y;
    }


    long add(long x, int y) {
        return x + y;
    }
}
```

<br>
<br>

---

### 오버로딩의 장점

오버로딩은 따라서 파라미터는 달라지지만 메소드의 목표가 똑같을 때, 메소드의 이름을 통일시킴으로써 다음과 같은 이점을 가짐.

1. 코드의 가독성을 높일수 있다.
2. 메소드에 사용되는 이름을 절약할 수 있음
3. 오류의 가능성을 줄여줌.

`println()` 메서드의 경우 여러 타입의 파라미터를 받을 수 있도록 한 대표적인 오버로딩의 예이다.

```java
println()
println(boolean x)
println(char x)
println(char[] x)
println(double x)
println(String x)
```

해당 메서드는 사용자가 입력한 파라미터를 토대로 적절한 원형을 찾아 호출함.

<br>
<br>

---

### 오버로딩과 가변인자

오버로딩 사용 시에는 가능한 가변인자를 사용한 메서드는 오버로딩하지 않는 것이 좋음. 메서드를 호출했을 때 구별하기가 어렵기 때문.

<br>

#### 가변인자(Variable Arguments)

특정 데이터타입의 **파라미터의 갯수를 고정하지 않고** 사용할 수 있게 하는 기능.

`데이터타입... 파라미터이름`으로 사용 가능하다.

```java
String sample1(String 1, String 2, String 3) {}// 기존 방식

String sample2(String... str) {} // 가변인자를 사용한 방식
```

가변인자를 사용하면 메서드 호출 시 인자를 입력하지 않아도 됨. (0개도 가능하기 때문에)

<br>
<br>
