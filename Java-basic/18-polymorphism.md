## 다형성(polymorphism)

**다형성(polymorphism)**이란 **여러가지 형태를 가질 수 있는 능력**을 의미하며, 자바에서는 다음과 같이 다형성을 구현함.

<br>

1. **한 타입의 참조변수가 여러 타입의 객체를 참조할 수 있도록 함**
2. **한 타입의 파라미터에 여러 타입의 인자가 들어올 수 있음**

<br>

상속에서 [IS-A 관계](https://github.com/shm-m/TIL/blob/main/Java-basic/16-inheritance.md)가 바로 다형성을 프로그램적으로 구현한 경우임.

다형성은 상속과 추상화랑 함께 OOP를 구성하는 특징 중 하나이며, 엄연히 말하면 상속과 추상화를 통해 다형성이 실현된다.

<br>
<br>

---

### 참조변수의 다형성

인스턴스 생성과 상속을 배우면서 특정 인스턴스를 생성하기 위해서는 해당 객체의 주소를 저장할 참조변수가 필요함을 알 수 있다.

이 때 참조변수는 인스턴스와 데이터타입이 일치하거나, 혹은 인스턴스의 부모 클래스를 데이터타입으로 둘 수 있음.

후자의 경우 이는 *참조변수와 인스턴스의 데이터타입이 일치하지 않는다*는 것을 의미한다. 그리고 이는 곧 해당 인스턴스의 모든 멤버를 사용할 수 없음을 뜻한다.

<br>

```java
class Tv {
    boolean power;
    int channel;

    void power() {
        power != power;
    }

    void channelUp {
        ++channel;
    }

    void channelDown {
        --channel;
    }
}

class SmartTv extends Tv {
    String url;

    void internet(String url) {
        ...
    }
}
```

위와 같이 클래스 Tv와 이를 상속받은 클래스 SmartTv가 있다면, 데이터타입이 SmartTv인 인스턴스를 생성하고자 할 떄 다음과 같은 참조변수를 사용할 수 있다.

```java
SmartTv s = new SmartTv();
Tv t = new SmartTv();
```

후자의 경우가 **다형성을 이용하여 부모 클래스를 참조변수로 둔 케이스이다.**

이와 같은 경우 인스턴스 타입은 SmartTv이지만, 참조변수의 타입이 Tv이므로 **참조변수 t로는 SmartTv의 모든 멤버를 사용할 수 없다.**

따라서 t는 SmartTv의 멤버 중 Tv 클래스로부터 상속받은 멤버(power, channel, power() 등..)만 사용 가능하다.

<br>

> 인스턴스는 참조변수에 따라 사용 가능한 멤버의 개수가 달라진다.

보통 참조변수는 인스턴스와 타입이 일치하거나, 인스턴스의 부모 클래스와 타입이 일치해야한다. 이는 사용 가능한 멤버의 갯수가 같거나 적어지는 것을 의미한다. 자식 클래스는 부모 클래스로부터 확장되는 것이지 축소되는 것은 아니기 때문이다.

<br>

따라서 이는 **자식 클래스의 참조변수가 부모 클래스의 인스턴스를 참조할 수 없음**을 의미한다. 참조변수가 사용할 수 있는 멤버의 갯수가 실제 인스턴스의 멤버보다 많아지면 존재하지 않는 멤버를 사용할 수 있는 가능성이 발생하기 때문이다.

<br>

- 부모 타입의 참조 변수는 자식 타입의 인스턴스를 참조할 수 있다.
- 그러나 자식 타입의 참조 변수는 부모 타입의 인스턴스를 참조 할 수 없다.

<br>

결국 참조변수의 타입이 참조변수가 참조하고 있는 인스턴스에서 사용할 수 있는 멤버의 개수를 결정하는 셈이다.

> 참조변수의 타입은 참조할 수 있는 객체의 종류와 사용할 수 있는 멤버의 수를 결정한다.

<br>
<br>

---

### 참조변수와 인스턴스

만약 부모 클래스에 선언된 멤버를 자식 클래스에서 중복적으로 선언할 경우, <u>부모타입의 참조변수가 자식타입의 인스턴스를 참조할때 무엇을 사용할 지에 대한 문제가 발생한다.</u>

이때, 중복된 변수는 **참조변수의 타입의 멤버변수**를 사용하게 된다. 만약 부모타입의 참조변수를 사용했다면, 부모 클래스의 멤버 변수를, 일치할 경우에는 그대로의 것을 사용하면 된다.

단, 메서드의 경우 오버라이딩을 하면 참조변수의 타입과 관계없이 항상 **인스턴스의 메서드가 호출된다.**

```java
class Parent {
    int x = 1;
    void name() {
        System.out.println("This is Parent");
    }
}

class Child extends Parent{
    int x = 2;
    void name() {
        System.out.println("This is Child");
    }
}

class Sample {
    public static void main(String args[]) {
        Parent p = new Child();
        Child c = new Child();
        System.out.println(p.x); // = 1
        p.name() // "This is Child"
        System.out.println(c.x); // = 2
    }
}

```

위의 예제에서 참조변수 p는 Child 타입의 인스턴스를 참조하지만, p.x는 Parent의 멤버변수 x를 사용한다.

그러나 메서드 name()은 참조변수의 타입에 영향을 받지 않으므로 그대로 참조하는 인스턴스 Child의 name()을 호출한다.

만약 메서드가 구현부에 각각의 클래스의 멤버 변수를 사용할 경우에는, 해당 메서드가 존재하는 클래스의 인스턴스 변수를 참조한다.

이처럼 인스턴스 변수에 직접 접근하는 것은 참조변수의 영향을 받으므로 **캡슐화**를 사용하는 이유가 되기도 한다.

> 멤버변수의 경우 참조변수의 타입에 따라 달라진다.

따라서 이를 구분하고 싶다면, `super`와 `this`를 사용하면 된다. 만약 Child 클래스 내에서 `super.x`와 `this.x`를 호출했다면 이는 참조변수와 관계없이 1과 2를 호출할 것이다.

<br>

#### 참조변수의 데이터타입이 인스턴스의 데이터타입의 부모 클래스일 때

- 멤버 변수 : 참조변수의 것 사용
- 메서드 : 인스턴스의 것 사용

<br>
<br>

---

### 참조변수와 배열 (여러 종류의 객체를 하나에 배열에 넣기)

부모 타입의 참조변수가 자식 타입의 인스턴스를 참조하는 것이 가능하기 때문에 부모 타입의 배열을 사용하면 자식타입의 인스턴스들을 요소로 사용할 수 있다.

만약 클래스 Device와 이를 상속받는 Tv, Phone, Audio가 있다고 가정하면, 해당 자식 클래스들은 Device 타입의 배열에 묶을 수 있는 것임.

```java
Device d1 = new Tv();
Device d1 = new Phone();
Device d1 = new Audio();

Device d = new Deviece[3];

d[0] = d1;
d[1] = d2;
d[2] = d3;

```

> 부모타입의 참조변수 배열을 사용하면 공통의 조상을 가진 서로 다른 종류의 객체를 배열로 묶어 다룰 수 있다.

<br>
<br>

---

### 참조변수의 형변환

일반적인 데이터타입처럼 참조형 데이터타입도 형변환이 가능하다. 단, 이는 **상속 관계에서만 실현 가능**하며, 자식타입 -> 부모타입으로의 형변환은 암시적으로, 부모타입 -> 자식타입으로의 형변환은 명시적으로 진행해야한다. 또한 전자를 업캐스팅(up-casting), 후자를 다운캐스팅(down-casting)이라고 칭함.

- **업캐스팅** : 자식 -> 타입 (암시적)
- **다운캐스팅** : 부모 -> 자식 (명시적)

```java
Tv t;
SmartTv s;

t = s; // 업캐스팅, 암시적 형변환
s = (SmartTv)t; // 다운캐스팅, 명시적 형변환
```

IS-A 관계 역시 암시적 형변환을 이용한 것이다. 따라서 `Tv t = new SmartTv();`는 `Tv t = (Tv)new SmartTv();`에서 형변환이 생략된 형태이다.

<br>
<br>

업캐스팅에서 형변환이 생략 가능한 이유는 <u>부모타입의 참조변수는 자식타입의 인스턴스보다 사용할 수 있는 멤버의 갯수가 적거나 같기 떄문이다.</u> 따라서 별다른 문제가 발생하지 않는다.

그러나 역의 경우는 인스턴스에서 존재하지 않는 멤버를 사용할 여지가 있기 때문에 반드시 명시적 형변환을 해줘야 한다.

<br>

다운 캐스팅의 경우, 앞서 자식타입의 참조변수는 부모타입의 인스턴스를 참조할 수 없다고 배웠기 때문에 말이 되지 않는 것처럼 여겨질 수 있음. 실제로, `s = (SmartTv)t;` 역시 컴파일은 가능하지만 실행 시에는 오류가 발생할 것이다. 형변환을 했어도 **참조하는 인스턴스는 변하지 않기 때문이다.**

따라서 오류가 발생하지 않으려면, **참조변수 t가 참조하고 있는 인스턴스의 타입이 SmartTv여야 한다.**

즉, 자식타입으로 형변환이 가능하려면 해당 참조변수가 부모클래스의 타입이더라도 실제 참조하고 있는 인스턴스는 자식타입이어야 한다.

<br>

> 상속관계에 있는 변수간의 형변환은 자유롭지만, 다운캐스팅의 경우 변환되는 변수가 참조하고 있는 인스턴스가 참조변수의 자손타입일 경우에는 형변환이 불가능하다.

<br>
<br>

---

### instanceof

따라서 다운캐스팅의 경우 참조변수가 가리키는 인스턴스의 타입이 무엇인지 확인할 필요가 있다. 이때 사용할 수 있는 것이 바로 instanceof 이다.

**instanceof**는 참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아볼 수 있게 해주는 **연산자**이다. (메소드 x)

```java
if (참조변수 instanceof 클래스명) {
    ...
}
```

연산의 결과로 참조변수가 **피연산자(클래스명)와 타입이 일치하거나, 자식타입의 인스턴스를 참조할 경우**에는 true를, 그렇지 않을 경우에는 false를 반환한다.

> instanceof를 통해 true의 값을 얻을 경우 참조변수는 검사한 타입으로 형변환이 가능해진다.

```java
void doWork(Tv t) {
    if (t instanceof SmartTv) {
        SmartTv s = (SmartTv)t; // t가 참조하고 있는 인스턴스의 타입이 SmartTv와 일치하거나, 그의 자손이므로 true
        s.internet(url);
    }
}
```

따라서 instanceof를 통해 true값을 얻을 경우 해당 참조변수를 피연산자의 타입으로 다운캐스팅해도 오류가 발생하지 않는다.

<br>
<br>

---

### 파라미터의 다형성

참조변수처럼 파라미터(매개변수) 역시 상속을 사용하여 다형적인 특성을 가질 수 있다. 파라미터의 다형성은 **파라미터 타입의 자식 타입이면 언제든지 인자로 받아들임**으로써 구현된다.

파라미터의 다형성은 보통 외부의 클래스에서 여러 클래스를 하나의 메소드에 인자로써 동시에 사용하고자 할 때 유용하다. 다형성을 이용하면 인자의 타입마다 번거롭게 메소드를 오버로딩할 필요가 없기 때문.

```java
class Product {
    int price;
}

class Pencil extends Product {}
class Pen extends Product {}
class Eraser extends Product {}

class Customer {
    int money;

    void buy(Product p) {
        money = money - p.price;
    }
}
```

만약 상점에 여러 잡화가 존재하고, 고객은 이 모든 잡화를 살 수 있다면, Customer 클래스의 buy() 메서드의 경우 오버로딩을 통해 각각의 잡화 클래스를 파라미터로 하는 메서드를 모두 작성해야한다.

그러나 다형성을 이용하면, 파라미터에 타입과 일치하거나, 그의 자식인 클래스가 인자로 들어오는 것을 허용하므로, Product를 상속받은 Pencil, Pen, Eraser의 인스턴스는 buy()메서드에 파라미터로써 작성되지 않아도 제공되는 것이 허락된다.

<br>

> 메서드의 파라미터의 자식 타입의 참조변수면 어느 것이나 파라미터로 받아들여진다.

출력 시 사용되는 PrintStream 클래스의 print 메서드 역시 `print(Object obj)`의 형태로 파라미터에 Object 타입의 변수가 선언되어 있다. Object는 모든 클래스의 조상이므로, 해당 메서드에는 어떤 타입의 인스턴스든 인자로 사용이 가능한 것이다.

<br>
<br>
