## 인터페이스(interface)

인터페이스는 일종의 추상 클래스이지만, 그 추상화 정도가 더 높아 **추상메서드와 상수**만을 가지는 클래스이다.

추상 클래스가 미완성 설계도라면 인터페이스는 밑그림만 그려진 기본 설계도와 같음.

자바에서는 다중 상속이 금지되는데 _(만약 다중 상속을 허용하면 각각의 조상 클래스에 동일한 이름의 메서드가 존재 시 오버라이딩의 출처가 모호해지기 때문)_,

이러한 다중상속의 한계를 극복한 것이 바로 인터페이스이다.

결론부터 말씀드리면 인터페이스와 추상 클래스는 존재 목적이 다릅니다. 추상 클래스는 그 추상 클래스를 상속받아서 기능을 이용하고, 확장시키는 데 있습니다. 반면에 인터페이스는 함수의 껍데기만 있는데, 그 이유는 그 함수의 구현을 강제하기 위해서 입니다.

인터페이스는 자바에서 금지된 다중상속의 한계를 극복하는 역할을 하기도 함.

<br>
<br>

### 인터페이스의 작성

```java
interface interfaceName {
    public static final 타입 상수이름 = 값;
    public abstract 리턴타입 메서드이름 (파라미터 목록);
}
```

인터페이스는 클래스 작성과 동일하나 키워드가 `class`가 아닌 `interface`.

또한, 앞서 말했듯이 인터페이스의 멤버는 상수와 추상 클래스만이 허용되므로 모든 멤버 변수 앞에는 `public static final`, 메서드 앞에는 `public abstract`가 붙어야 한다. 단, 이는 인터페이스에서 필수적인 부분이기에 생략해도 자바 컴파일러가 자동으로 추가해줌.

> 단 자바 1.8부터는 인터페이스에도 static 메서드와 default 메서드는 예외적으로 허용됨.

<br>
<br>

### 인터페이스의 상속

인터페이스는 <u>인터페이스로부터만 상속 가능.</u> 클래스와 다르게 **다중상속**이 가능하다.

자식 인터페이스는 조상 인터페이스 내 추상 메서드의 구현부를 구현할 필요가 없기 때문에
다중 상속으로 인한 메서드의 출처 모호성이 발생할 여지가 없기 때문이다.

```java
interface Movable {
    void move (int x, int y);
}

interface Attackable {
    void attack (Unit u);
}

interface Fightable extends Movable, Attackable { }
```

인터페이스 Fightable의 경우 Movable, Attackble을 상속받는 자손 인터페이스이다. Fightable의 경우 추가적으로 필요한 메서드가 없는 경우 아무것도 정의하지 않아도 조상 인터페이스의 추상 메서드들을 멤버로 가질 수 있다.

<br>
<br>

### 인터페이스의 구현

인터페이스 역시 일종의 설계도이므로 인터페이스 자체로는 인스턴스를 생성할 수 없으며, 이를 상속받는 클래스가 필요하다.
단 인터페이스는 특정 클래스로 구체화할 때 상속이 아닌 **구현**으로 표현하며, 구현하는 클래스 뒤에 extends 대신 **implement**라는 키워드를 붙여준다. <u> 또한 상속과 구현은 아래와 같이 동시에 가능하다. </u>

```java
class Fighter extends Unit, implements Fightable {
    public void move (int x, int y);
    public void attack (Unit u);
}
```

앞서 언급했듯이 인터페이스의 모든 메서드는 <u> 추상 클래스이므로, 이를 구현하는 클래스에서는 인터페이스 내 모든 메서드를 구현해줘야 한다. </u>

만약 일부만 구현하고 싶으면 구현되는 클래스는 추상 클래스로 선언되어야 함.

또한 오버라이딩 시에는 조상의 메서드보다 더 넓은 범위의 접근 제어자를 지정해야하는데, 따라서 인터페이스 내 추상 클래스는 모두 접근 제어자가 `public`이므로 구현 클래스 내의 메서드 역시 접근 제어자가 `public`이어야 한다.

<br>
<br>

### 인터페이스를 통한 다중 상속

앞서 다중 상속은 메서드 출처의 모호성으로 인하여 자바에서는 금지되어 있음. 따라서 만약 두개의 클래스로부터 상속을 받아야 하는 상황이라면, 두 조상 클래스 중 비중이 높은 것을 상속의 대상으로 선택하고, 비중이 낮은 것은 필요한 부분만 뽑아내어 **추상화**를 통해 인터페이스로 구현하면 된다.

<br>
<br>

### 인터페이스를 통한 다형성

다형성의 특징에는 자손클래스의 인스턴스의 참조변수를 조상타입으로 지정할 수 있다는 것에 있음.
인터페이스 역시 <u>인터페이스를 참조변수로 두고 이를 구현한 클래스의 인스턴스를 참조할 수 있으며, 형변환도 가능하다.</u>

```java
Fightable f = (Fightable) new FIghter();
```

<br>

> 따라서 인터페이스는 메서드의 파라미터로 사용 가능하다.

```java
void attack(Fightable f) {

}
```

단, 인터페이스를 파라미터로 사용한다는 것은 **해당 인터페이스를 구현한 클래스의 인스턴스를 인자로 넣는 것**이지, 인터페이스 자체를 넣는 것은 불가능하다. (애초에 인터페이스는 인스턴스를 만들지 못하므로)

```java
Fightable method() {
    return new Fighter();
}
```

반환타입도 인터페이스를 넣는 것이 가능하나, 이 역시 해당 인터페이스를 구현한 클래스의 인스턴스를 넣는다는 의미이다.

<br>
<br>

### 인터페이스의 장점

1. **개발 시간을 단축 가능하다**
   인터페이스는 다형성을 이용하였기 때문에 메서드를 호출하는 쪽에서는 선언부만 알면 사용이 가능. 따라서 인터페이스를 구현하는 클래스가 완성되지 않아도 동시에 개발이 가능하다.
2. **표준화가 가능하다**
   프로젝트의 기본틀을 인터페이스로 작성하면 일관되고 정형화된 프로그램 개발이 가능해짐.
3. **서로 관계없는 클래스들의 관계를 맺어줄 수 있음**
   서로 상속관계에 있지도, 조상클래스를 공유하지도 않은 클래스들에게 하나의 인터페이스를 공통적으로 구현하도록 강제함으로써 공통점을 만들어줄 수 있음.
4. **독립적인 프로그래밍 가능**
   인터페이스를 사용하면 선언과 구현을 분리할 수 있어 클래스간의 직접적인 관계를 인터페이스를 통해 간접적인 관계로 만들어 줄 수 있음. 따라서 결합도를 낮추어 한 클래스가 변경되어도 관련된 다른 클래스에 영향이 가지 않도록 함

<br>
<br>

### 인터페이스의 이해

앞선 인터페이스의 장점 중 3번과 4번에 대해 보다 자세하게 설명하면 다음과 같다.

<br>

#### 클래스간의 관계를 맺어준다.

만약 게임 내 몬스터들을 클래스로 정의한다 햇을 때 최고 조상인 `Monster` 클래스와 이를 상속한 `Bokoblin`과 `Moblin` 클래스가 각각 있다고 가정하자. 또한 각각의 몬스터는 전사형과 궁수형으로 나뉜다. 만약, `WarriorBokoblin`(전사형 보코블린)이 있다면 이는 `Bokoblin` 클래스를, `WarriorMoblin`(전사형 모리블린)이 있다면 이는 `Moblin`을 상속받을 것이다.

그러나 앞서 말한 클래스들은 칼이나 몽둥이와 같은 무기를 들고 전투하는 전사형 몬스터라는 공통점을 가진다. 이를 별도의 클래스로 작성하기엔 자바는 다중 상속을 지원하지 않는다. 따라서 Warrior라는 별도의 인터페이스를 작성한다면 각각의 클래스의 공통점을 뽑아내어 두 클래스 간의 관계를 만들어 줄 수 있다.

즉, 굳이 두 클래스의 공통 조상까지 거슬러 올라가 해당 조상에 메서드를 추가할 필요가 없는 셈이다.

<br>

또한 앞서 말했듯이 인터페이스는 파라미터로 설정이 가능하다. 만약 클래스 A(User)에 클래스 B(Provider)의 인스턴스를 생성하고 메서드를 호출한다고 가정했을 때 A와 B는 직접적인 관계가 된다.

```java
Class A {
    public void methodA(B b) {
        b.methodB ();
    }
}
```

이 떄 클래스 B에 변경사항이 생기거나 대체가 필요할 경우 A에 까지 영향을 끼치게 된다. 그러나 클래스 A의 메서드의 파라미터로 B가 아닌 이를 추상화한 인터페이스로 대체된다면, 직접적인 관계로 인한 문제가 발생하지 않는다.

즉 A-B라는 직접적인 관계에서 A-I-B라는 **간접적인 관계로 변경함으로써 클래스간 결합도를 낮추게 되는 것이다.**

이러한 방법은 로그 프레임워크 중 **slf4j**에서 사용하는 방식이다. slf4j는 logger 추상체로써 logback이나 log4j2와 같은 로킹 프레임워크의 인터페이스의 역할을 함. 따라서 slf4j2를 이용하면 코드를 일정하게 유지하면서 다른 로깅 프레임워크로의 전환을 손쉽게 할 수 있다.

<br>

```java
Interface I {
    public abstract void methodB ();
}

class B implements I {
    public void methodB {
        System.out.println("this is methodB().");
    }
}

// 직접적인 관계에서 간접적인 관계로 변경
class A {
    public void methodA(I i) {
        i.methodB();
    }
}

```

이 떄 클래스 A는 사용하는 입장(User)로써 실제로 사용하는 클래스의 이름과 구현부를 몰라도 된다. 추후에 인자를 통해서만 인터페이스를 구현한 클래스의 인스턴스를 아래와 같이 동적으로 제공받기만 하면 된다.

```java
public static void main(String[] args) {
    A a = new A();
    a.methodA(new B());
}
```

<br>

심지어는 파라미터에 동적으로 인스턴스를 제공받지 않고 제3의 클래스를 통해서 제공받을 수도 있다.

```java
class A {
    void methodA() {
        I i = InstanceManager.getInstance();
        i.methodB();
    }
}

class IntanceManager {
    public static I getInstance)() {
        return new B();
    }
}
```

위의 방식이 바로 인스턴스를 그떄 그때 동적으로 생성하는 것이 아닌 getInstance()라는 메서드를 통해 제공받는 방법이다. 이렇게 하면 나중에 다른 클래스로 변경되어도, User 쪽에서 변경하지 않고도 인스턴스를 제공하는 클래스만 변경하면 된다.
**싱글톤 방식**이 이와 유사한 방식으로 제공되는 것이다.

<br>
<br>

### default / static 메서드

자바 1.8 이상부터는 인터페이스에서도 추상클래스 뿐만 아니라 디폴트, 스태틱 메서드를 사용 가능하도록 허용했다.

**스태틱 메서드**의 경우 인스턴스와 관계없는 독립적인 메서드이기 때문에 추가하지 못할 이유가 없었으나 자바 규칙의 단순성의 목적으로 제한되었다가 1.8부터 허용되었다.

**디폴트 메서드**의 경우는 **인터페이스의 수정**을 고려하여 추가되었다. 최대한 섬세한 설계를 통해 인터페이스를 변경하지 않는 편이 좋지만 어쩔 수 없이 변경하는 경우도 존재할 것이다. 만약 새로운 메서드가 추가될 경우에는 인터페이스는 무조건적으로 추상 메서드를 사용해야하므로 이를 구현한 모든 클래스의 메서드 역시 수정해줘야 한다.

이때 <u>디폴트 메서드를 사용하면 해당 인터페이스를 구현한 클래스를 변경하지 않아도 된다.</u>
