## 메소드(method)

**메소드**란, 자바에서의 기능을 뜻한다.

타 프로그래밍 언어에서의 **함수**와 같은 의미. 자바는 함수가 클래스없이 생성될 수 없기 때문에 클래스 내의 함수를 메소드라고 함.

메소드를 통해 코드를 매번 처음부터 끝까지 적는 것이 아니라 자주 사용하는 코드들을 묶어서 한개의 메소드로 만들어줄 수 있다. 그리고 해당 메소드의 이름만 호출해서 그 기능들을 모두 실행 가능.

> 즉, 메소드는 특정 작업을 수행하는 일련의 문장들을 하나로 묶은 것

따라서 메소드는 다음과 같은 이점을 가진다.

1. 높은 재사용성
2. 불필요한(중복된) 코드 제거
3. 프로그램의 구조화

<br>

### 메소드의 선언과 구현

#### 메소드 구조

```java

접근제어자 리턴타입 메소드이름(파라미터 목록) { // 선언부

// 구현부

return 리턴값;

}

```

<br>

#### 메소드의 선언

메소드의 선언부에서는 해당 메소드가 작업을 수행하기 위해 필요한 값과 결과로 반환할 값의 타입에 대해 지정함.

- **접근 제어자** : 해당 메소드에 접근할 수 있는 범위.

- **리턴타입** : 해당 메소드가 종료되면서 호출한 곳으로 보내줄 값의 데이터타입.
  리턴 타입이 존재할 때는 반드시 메소드 내부에서 return이라는 명령어를 통해서 해당 데이터타입의 값을 return 해줘야 한다.

- **메소드 이름** : 메소드를 호출하기 위한 이름

- **파라미터** : 해당 메소드를 실행하는데 반드시 필요로 하는 외부의 값.
  파라미터는 유효범위가 해당 메소드 전체인 변수로 취급되기 때문에 변수의 선언식처럼 "데이터 타입 이름" 으로 파라미터가 구성된다.

```java
int plus(int num1, int num2) {
    int result = num1 + num2;
    return result;
}
```

해당 메소드는 plus에 두개의 int를 파라미터에 입력받아, 두 값을 더한 결과값 result(역시 int)를 반환한다는 정보를 제공.

메소드는 `입력값 -> 메소드 -> 리턴값`과 같은 과정을 걸침. 사용자는 입력값을 입력하고 리턴값만 취하면 되기 때문에 메소드의 구조를 몰라도 됨 (메소드를 블랙박스라고 비유하는 이유)

단 주의해야 할 점은*메소드의 입력값과 리턴값은 필수가 아니라는 것이다.* 만약 외부의 값이 필요없을 경우에는 파라미터는 적지 않아도 되고, 만약 아무런 값도 보내주지 않을 때는 리턴타입 역시 `void`라고 적어주고 리턴값을 입력하지 않아도 됨.

1. 외부의 값도 필요로 하지 않고, 아무런 값도 리턴하지 않는 형태의 메소드 (파라미터와 리턴타입이 둘다 부재)

```java
static void showMyName() {
   System.out.println("안녕하세요.");
}
```

2. 파라미터는 존재하나 리턴값 부재 (void 사용)

```java
static void showMyAge(int age) {
   System.out.println("안녕하세요.");
   System.out.println("제 나이는" + age + "입니다.");

}
```

`System.out.println`문은 메소드내에서 사용되어지는 문장일 뿐, 돌려주는 값은 없다.

3. 파라미터는 존재하지 않지만 리턴 값이 존재하는 경우

```java
static int getAge() {
   return 5;
}
```

<br>

#### 메소드의 구현

구현부는 메소드의 고유 기능을 수행하는 명령문의 집합임. 기존의 코드 작성 방법대로 작성하면 된다.

단 반환할 데이터가 있는 경우 return문 존재.

- **return문** : `return 반환값;`의 형태로 해당 문장은 메소드의 결과인 반환값을 호출한 메소드로 전달함.
  이 떄 반환값의 타입은 선언부에서 작성한 반환타입과 일치하거나 자동 형변환이 가능한 것이어야 함.
  복수 개를 입력할 수 있는 파라미터와 달리 리턴값은 하나만 가능

또한 리턴 값의 경우 해당 메소드를 빠져나갈 때 사용할 수도 있다. 리턴타입을 void로 지정한 뒤 return문에 아무런 값을 입력하지 않을 시 사용 가능

<br>

##### 메소드 내에서 선언된 변수 (지역 변수)

메소드 내에서 선언된 변수는 해당 메소드 내에서만 사용 가능, 해당 변수를 **지역변수**라고 함(Local Variable)

따라서 같은 클래스 내에 존재해도 서로 다른 메소드 내에서 선언된 변수는 동일한 타입이면서 같은 이름을 가져도 됨.

이 말은 곧 메소드 외부에서 선언된 변수는 메소드 내부에 전달되어 로직을 수행해도 원본 값에는 영향을 받지 않는다는 얘기다.

```java
public class AgeTest {
    static int increaseAge(int age) {
        return age + 1;
    }

    public static void main(String[] args) {
        int age = 7;
        int newAge = increaseAge(age);
        System.out.println(age);
    }
}
```

이 때 age 를 출력 시 increaseAge 메서드가 적용된 값 8이 아닌, 그대로 7이 출력된다.

<br>

그러나 메소드가 객체를 전달 받으면 메소드 내의 객체는 전달받은 객체 그 자체로 수행된다. 따라서 메소드가 종료되어도 해당 값이 남아있음.

```java
public class AgeTest {
    int age;
    void increaseAge(AgeTest test) { // 파라미터가 객체
        test + 1;
    }

    public static void main(String[] args) {
        AgeTest test = new AgeTest();
        test.age = 7;
        test.increaseAge(test);
        System.out.println(test.age);
    }
}
```

이때는 1이 증가한 8이 출력. 객체를 메소드의 입력으로 넘기고 메소드가 객체의 속성값을 변경하면 메소드 수행 이후에도 객체는 변경된 속성값을 유지한다.

메소드의 입력항목이 값인지 객체인지를 구별하는 기준은 입력항목의 자료형이 primitive 자료형인지 아닌지에 따라 나뉜다.

**int 자료형과 같은 primitive 자료형인 경우 값만 전달되는 것이고 그 이외의 경우(reference 자료형)는 객체가 전달되는 것이기 때문.**

<br>

---

### 메소드 호출

메소드는 클래스의 멤버 참조 연산자(.)를 사용하여 호출 가능.
같은 클래스 내에서는 참조 변수가 필요없지만 다른 클래스에서는 메소드가 속한 클래스의 인스턴스를 생성한 다음 참조 변수를 통해 호출해야함

```java
// 파라미터 유
참조변수이름.메소드이름();

//파라미터 무
참조변수이름.메소드이름(인수 목록);
```

- **인수** : 메소드를 호출 시 전달하는 입력값
  메소드에 입력으로 전달된 값을 받는 변수를 의미하는 파라미터와 다름

<br>

따라서 위에서 생성했던 `increaseAge` 메소드를 타 클래스에서 호출할 경우에는 다음과 같이 작성해야함

```java
AgeTest t = new Agetest(); // 참조변수 t 생성
t.increaseAge(8);
```

<br>

#### 반환값(return value)

리턴타입이 void가 아닐 경우 메소드는 반드시 데이터를 반환함. 따라서 **메소드의 결과를 저장할 변수**가 필요.

결과를 저장하는 변수는 반환 값과 타입이 일치하거나 자동 형변환 될 수 있는 타입이여야 함
